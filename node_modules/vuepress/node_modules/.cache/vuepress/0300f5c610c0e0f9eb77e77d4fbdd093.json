{"remainingRequest":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/docs/blog/vue-source-study.md?vue&type=template&id=b2e9fb90&","dependencies":[{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/docs/blog/vue-source-study.md","mtime":1549463072835},{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jerry/Development/WEB/webWorkSpace/LIJIATING/vuepressBlog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":499162500000}],"contextDependencies":[],"result":["\n<div class=\"content\"><p>终于有时间静下来学习一下vue源码了。\n<!-- more --></p>\n<h2 id=\"_1-生命周期\"><a class=\"header-anchor\" href=\"#_1-生命周期\" aria-hidden=\"true\">#</a> 1. 生命周期</h2>\n<table>\n<thead>\n<tr>\n<th>生命周期钩子</th>\n<th style=\"text-align:center\">组件状态</th>\n<th>最佳实践</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td style=\"text-align:center\">实例初始化之后，this指向创建的实例，不能访问到data、computed、watch、methods上的方法和数据</td>\n<td>常用于初始化非响应式变量</td>\n</tr>\n<tr>\n<td>created</td>\n<td style=\"text-align:center\">实例创建完成，可以访问到data、computed、watch、methods上的方法和数据，未挂载DOM，不能访问$el,$ref属性内容为空数组</td>\n<td>常用于简单的ajax请求，页面的初始化</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td style=\"text-align:center\">实例挂载之前，找到对应的template编译为render函数</td>\n<td></td>\n</tr>\n<tr>\n<td>mounted</td>\n<td style=\"text-align:center\">实例挂载到DOM上，可以获取到DOM节点，可以访问$ref属性</td>\n<td>常用于操作DOM和ajax请求</td>\n</tr>\n<tr>\n<td>beforeupdate</td>\n<td style=\"text-align:center\">响应式数据更新前调用，发生在虚拟DOM打补丁之前</td>\n<td>常用于在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</td>\n</tr>\n<tr>\n<td>updated</td>\n<td style=\"text-align:center\">虚拟DOM重新渲染和打补丁之后调用，组件DOM已更新</td>\n<td>可执行依赖与新DOM的操作，避免在这个钩子中操作数据，可能陷入死循环</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td style=\"text-align:center\">实例销毁之前调用，这一阶段this仍可获取到实例</td>\n<td>常用于销毁定时器，解绑全局事件，销毁插件对象等操作</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td style=\"text-align:center\">实例销毁后调用，调用后Vue实例的所有东西都会解绑，所有事件监听器都会被移除，所有的子组件会被销毁</td>\n<td></td>\n</tr>\n<tr>\n<td>activated</td>\n<td style=\"text-align:center\"></td>\n<td></td>\n</tr>\n<tr>\n<td>deactivated</td>\n<td style=\"text-align:center\"></td>\n<td></td>\n</tr>\n<tr>\n<td>errorCaptured</td>\n<td style=\"text-align:center\"></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<div class=\"warning custom-block\"><p class=\"custom-block-title\">created阶段与mounted阶段ajax请求的区别：</p>\n<p>前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态；mounted 不会承诺所有的子组件也都一起被挂载，如果你希望等到整个视图都渲染完毕，可以用 <strong>vm.$nextTick</strong></p>\n</div>\n<h2 id=\"_2-响应式原理\"><a class=\"header-anchor\" href=\"#_2-响应式原理\" aria-hidden=\"true\">#</a> 2. 响应式原理</h2>\n<div class=\"warning custom-block\"><p class=\"custom-block-title\">computed 和 watch 的差异：</p>\n<ul>\n<li>computed 是计算一个新的属性，并将该属性挂载到 vm（Vue 实例）上，而 watch 是监听已经存在且已挂载到 vm 上的数据，所以用 watch 同样可以监听 computed 计算属性的变化（其它还有 data、props）;</li>\n<li>computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值，而 watch 则是当数据发生变化便会调用执行函数;</li>\n<li>从使用场景上说，computed 适用一个数据被多个数据影响，而 watch 适用一个数据影响多个数据；</li>\n</ul>\n</div>\n<h2 id=\"_3-vue选项合并\"><a class=\"header-anchor\" href=\"#_3-vue选项合并\" aria-hidden=\"true\">#</a> 3. Vue选项合并</h2>\n<ul>\n<li>对于 el、propsData 选项使用默认的合并策略 defaultStrat。</li>\n<li>对于 data 选项，使用 mergeDataOrFn 函数进行处理，最终结果是 data 选项将变成一个函数，且该函数的执行结果为真正的数据对象。</li>\n<li>对于 生命周期钩子 选项，将合并成数组，使得父子选项中的钩子函数都能够被执行</li>\n<li>对于 directives、filters 以及 components 等资源选项，父子选项将以原型链的形式被处理，正是因为这样我们才能够在任何地方都使用内置组件、指令等。</li>\n<li>对于 watch 选项的合并处理，类似于生命周期钩子，如果父子选项都有相同的观测字段，将被合并为数组，这样观察者都将被执行。</li>\n<li>对于 props、methods、inject、computed 选项，父选项始终可用，但是子选项会覆盖同名的父选项字段。</li>\n<li>对于 provide 选项，其合并策略使用与 data 选项相同的 mergeDataOrFn 函数。</li>\n<li>最后，以上没有提及到的选项都将使默认选项 defaultStrat。</li>\n<li>最最后，默认合并策略函数 defaultStrat 的策略是：只要子选项不是 undefined 就使用子选项，否则使用父选项。</li>\n</ul>\n</div>\n",null]}